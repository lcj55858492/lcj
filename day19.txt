1.编程题
  分别使用继承和实现接口的方式创建并启动线程，在run()方法打印1 ~ 20之间的整数。

作业：
----------------------------------------------------------------------------------
今天内容：
   (1)线程的常用方法
   (2)线程的同步机制

1.线程的常用方法
1.1 线程的名称和编号(会用即可)
    long getId() - 用于获取线程的编号。
    String getName() - 用于获取线程的名称。
    void setName(String name) - 用于设置线程的名称。
    static Thread currentThread() - 用于返回当前正在执行线程对象的引用。

1.2 常用的方法(重点)
    static void sleep(long millis) 
        - 用于让当前正在执行的线程休眠参数指定的毫秒数。
    int getPriority() - 用于获取线程的优先级。
    void setPriority(int newPriority) - 用于设置线程的优先级。
        - 优先级越高的线程表示获取时间片的机会越多，但不保证一定先执行。
    void join() - 用于等待调用对象所表示的线程终止。
    void join(long millis) - 用于表示等待的时间最长为参数指定的毫秒数。
    boolean isDaemon() - 用于判断是否为守护线程。
    void setDaemon(boolean on) - 用于设置该线程为守护线程。
        - 当所有非守护线程结束后，则守护线程随之结束，该方法的调用必须在启动之前。
      
2.线程的同步机制(重点)
2.1 基本概念
   当多个线程同时访问同一种共享资源时，可能会造成数据的不一致和覆盖等问题，此时就需要对线程之间进行协调和通信，该机制就叫线程的同步机制。

如：
   03年左右    银行开户   存折  银行卡    对应同一个账户
 
2.2 解决方案
   由程序结果可知：当两个线程同时执行取款操作时，会造成最终的账户余额不合理。
   引发原因：线程一还没来得及将取款后余额写入数据库，此时线程二已经开始执行。
   解决方案：将线程的并行改为串行即可，也就是线程一写入数据库后线程二再执行。
   带来问题：多线程同时执行多个任务的效率降低，因此尽可能减少串行的范围。 
 
2.3 实现方式
   在Java语言中使用synchronized关键字来实现同步/对象锁的效果，来保证每个线程执行的原子性，具体方式如下：
   (1)使用同步语句块的方式实现
      synchronized(对象的引用){
          主要编写所有需要被锁定的代码;
      } 
   (2)使用同步方法的方式实现
      使用synchronized关键字修饰方法即可;
      该方式等价于 synchronized(this){}的方式。
  
2.4 实现原理
   当多个线程同时启动后会抢占共享资源，若其中一个线程抢到共享资源则会自动加锁，其它只能进入阻塞状态，当该线程使用完毕共享资源后会自动解锁，此时阻塞状态的线程又可以抢占共享资源，抢不到的线程继续阻塞。

2.5 死锁的概念(了解)
线程一执行的代码：
    public void run(){
        synchronized(a){   //持有对象锁a等待对象锁b
            synchronized(b){
                ...
            }
        }
    }  
       
线程二执行的代码：
    public void run(){
        synchronized(b){   //持有对象锁b等待对象锁a
            synchronized(a){
                ...
            }
        }
    }      
 
注意：
   在以后的开发中尽量不要使用同步语句块的嵌套结构。  
 
作业：
   1.复习和理解线程同步机制。
   2.参考并编写学生信息管理系统的案例。
   3.有余力的同学自己学习生产者消费者模型的案例。   
 









  